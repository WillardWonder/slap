<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Slap Jam: Online Championship</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Press+Start+2P&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            color: white;
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            touch-action: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            aspect-ratio: 4/3;
            background: #1a1a1a;
            box-shadow: 0 0 50px rgba(0,0,0,1);
            border: 8px solid #333;
            overflow: hidden;
            border-radius: 4px;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI LAYER */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            padding: 15px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            pointer-events: none;
        }

        .p-card { 
            width: 35%; 
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .profile-pic {
            width: 50px; height: 50px;
            background: #222;
            border: 2px solid #fff;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            border-radius: 5px;
            flex-shrink: 0;
        }
        .profile-pic canvas { width: 100%; height: 100%; }

        .stat-block { flex-grow: 1; min-width: 0; }

        .name { 
            font-size: 14px; 
            margin-bottom: 4px; 
            text-shadow: 2px 2px 0 #000; 
            color: #fff; 
            font-family: 'Black Ops One'; 
            letter-spacing: 1px; 
            white-space: nowrap; 
            overflow: hidden; 
            text-overflow: ellipsis; 
        }
        .hp-bar-bg { width: 100%; height: 12px; background: #330000; border: 2px solid #555; position: relative; transform: skew(-10deg); }
        .hp-bar-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #00ff00, #00aa00); transition: width 0.2s; }
        
        #turn-indicator {
            position: absolute; top: 20%; width: 100%; text-align: center;
            font-family: 'Black Ops One'; font-size: 30px; color: #ffff00; 
            text-shadow: 0 0 10px #ffaa00, 3px 3px 0 #000;
            opacity: 0; transition: opacity 0.2s; pointer-events: none;
        }

        /* METER & POWER DECAY */
        #meter-wrapper {
            position: absolute; bottom: 120px; left: 50%;
            transform: translateX(-50%);
            width: 70%; 
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 10;
        }

        #power-decay-label {
            font-size: 10px; color: #aaa; margin-bottom: 5px;
            text-shadow: 1px 1px 0 #000;
        }

        #meter-container {
            width: 100%; height: 40px;
            background: #222; border: 3px solid #fff;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            position: relative;
        }

        .zone-ok { position: absolute; left: 0; width: 100%; height: 100%; background: #550000; } 
        .zone-good { position: absolute; left: 30%; width: 40%; height: 100%; background: #ddaa00; } 
        .zone-perfect { 
            position: absolute; left: 48%; width: 4%; height: 100%; 
            background: #00ff00; box-shadow: 0 0 15px #fff; z-index: 5;
        } 
        
        #needle {
            position: absolute; left: 0; top: -5px; bottom: -5px;
            width: 6px; background: #fff; border: 2px solid #000;
            transform: translateX(-50%);
            z-index: 10;
        }

        /* ACTION BUTTON */
        #action-btn {
            position: absolute; bottom: 30px; left: 50%;
            transform: translateX(-50%);
            padding: 15px 40px;
            background: #0044aa; color: white; border: 3px solid white;
            font-family: 'Black Ops One'; font-size: 24px;
            border-radius: 8px; cursor: pointer; pointer-events: auto;
            display: none; animation: pulse 0.5s infinite alternate;
            text-shadow: 2px 2px 0 #000;
            box-shadow: 0 6px 0 #002266;
            white-space: nowrap;
            z-index: 20;
        }
        #action-btn:active { transform: translateX(-50%) translateY(4px); box-shadow: 0 2px 0 #002266; }
        @keyframes pulse { from{transform:translateX(-50%) scale(1);} to{transform:translateX(-50%) scale(1.05);} }

        #announcer {
            position: absolute; top: 40%; left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Black Ops One'; font-size: 60px;
            color: white; text-align: center;
            text-shadow: 5px 5px 0 #000, -2px -2px 0 #ff0000;
            opacity: 0; pointer-events: none; white-space: nowrap;
            z-index: 30;
        }

        /* CHAT */
        #chat-input-area {
            position: absolute; bottom: 10px; right: 10px;
            display: none; /* Shown in game */
            gap: 5px; pointer-events: auto;
        }
        #chat-input {
            background: rgba(0,0,0,0.5); border: 1px solid #666; color: white;
            padding: 5px; font-family: 'Press Start 2P'; font-size: 10px; width: 150px;
        }
        #chat-send {
            background: #444; border: 1px solid #fff; color: white;
            font-family: 'Press Start 2P'; font-size: 10px; cursor: pointer;
        }

        /* MENUS */
        .menu-screen {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: rgba(10,10,10,0.95);
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 100; pointer-events: auto;
            padding: 20px; box-sizing: border-box;
        }
        .title { 
            font-family: 'Black Ops One'; font-size: 50px; color: #ffcc00; 
            margin-bottom: 20px; text-align: center; text-shadow: 0 5px 0 #550000;
            line-height: 1.1;
        }
        .menu-btn {
            padding: 12px 20px; font-family: 'Press Start 2P'; font-size: 14px;
            background: #cc0000; color: white; border: 3px solid #fff; cursor: pointer;
            margin-top: 15px; box-shadow: 0 6px 0 #550000; transition: transform 0.1s;
            width: 260px; text-align: center;
        }
        .menu-btn:active { transform: translateY(6px); box-shadow: none; }

        .char-select { display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; justify-content: center; }
        .char-icon { 
            width: 70px; height: 70px; border: 3px solid #444; 
            cursor: pointer; display: flex; justify-content: center; align-items: center;
            background: #222; transition: 0.2s; position: relative;
            overflow: hidden;
            border-radius: 6px;
        }
        .char-icon canvas { width: 100%; height: 100%; }
        .char-icon.selected { border-color: #ffcc00; background: #555; transform: scale(1.1); box-shadow: 0 0 15px #ffcc00; }
        
        #room-code-input {
            margin-top: 10px; padding: 10px; font-size: 24px; text-transform: uppercase;
            text-align: center; font-family: 'Black Ops One'; width: 180px; letter-spacing: 2px;
        }

        .status-msg { margin-top: 20px; color: #aaa; font-size: 12px; text-align: center; line-height: 1.5; min-height: 20px; }
        #room-display { position: absolute; top: 10px; right: 10px; color: #888; font-size: 10px; font-family: monospace; }
        
        /* AUDIO BTN */
        #audio-toggle {
            position: absolute; top: 10px; left: 10px;
            font-size: 20px; cursor: pointer; color: #555;
            z-index: 101; pointer-events: auto;
        }
        #audio-toggle.on { color: #00ff00; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div id="audio-toggle" onclick="toggleAudio()">ðŸ”‡</div>
        <div id="room-display"></div>
        <div class="hud-top">
            <div class="p-card">
                <div class="profile-pic"><canvas id="p1-profile"></canvas></div>
                <div class="stat-block">
                    <div class="name" id="p1-name">PLAYER 1</div>
                    <div class="hp-bar-bg"><div id="p1-hp" class="hp-bar-fill"></div></div>
                </div>
            </div>
            <div class="p-card" style="flex-direction: row-reverse; text-align: right;">
                <div class="profile-pic"><canvas id="p2-profile"></canvas></div>
                <div class="stat-block">
                    <div class="name" id="p2-name">OPPONENT</div>
                    <div class="hp-bar-bg"><div id="p2-hp" class="hp-bar-fill" style="float: right;"></div></div>
                </div>
            </div>
        </div>

        <div id="turn-indicator">WAITING...</div>

        <div id="meter-wrapper">
            <div id="power-decay-label">POTENTIAL POWER: 100%</div>
            <div id="meter-container">
                <div class="zone-ok"></div>
                <div class="zone-good"></div>
                <div class="zone-perfect"></div>
                <div id="needle"></div>
            </div>
        </div>

        <div id="action-btn">SLAP!</div>
        <div id="announcer"></div>

        <div id="chat-input-area">
            <input type="text" id="chat-input" placeholder="Type..." maxlength="20">
            <button id="chat-send" onclick="sendChatMessage()">SEND</button>
        </div>
    </div>

    <!-- MAIN MENU -->
    <div id="menu-main" class="menu-screen">
        <div class="title">SLAP JAM:<br>ONLINE</div>
        <div class="char-select" id="char-list"></div>
        <div id="char-stats" style="color: #fff; font-size: 14px; height: 20px; text-shadow: 2px 2px 0 #000; margin-bottom: 20px;"></div>
        
        <button class="menu-btn" onclick="startSinglePlayer()">VS CPU</button>
        <button class="menu-btn" onclick="showMultiplayerMenu()">ONLINE MULTIPLAYER</button>
    </div>

    <!-- MULTIPLAYER MENU -->
    <div id="menu-multi" class="menu-screen" style="display:none;">
        <div class="title">ONLINE LOBBY</div>
        
        <div style="background: #333; padding: 10px; border-radius: 5px; margin-bottom: 20px; text-align: center; width: 100%; max-width: 280px;">
            <div style="font-size: 10px; color: #aaa;">YOU ARE PLAYING AS:</div>
            <div id="selected-char-display" style="color: #ffcc00; font-family: 'Black Ops One'; font-size: 18px; margin-top: 5px;"></div>
        </div>

        <button class="menu-btn" onclick="findQuickMatch()">QUICK MATCH</button>
        
        <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #444; width: 100%; max-width: 300px; display:flex; flex-direction:column; align-items: center;">
            <div style="color:#888; font-size: 10px; margin-bottom: 5px;">PRIVATE ROOM CODE</div>
            <input type="text" id="room-code-input" placeholder="CODE" maxlength="4">
            <div style="display:flex; gap:10px; width: 100%; justify-content: center;">
                <button class="menu-btn" style="width: 120px; font-size: 12px; margin-top: 10px;" onclick="createPrivateRoom()">CREATE</button>
                <button class="menu-btn" style="width: 120px; font-size: 12px; margin-top: 10px;" onclick="joinPrivateRoom()">JOIN</button>
            </div>
        </div>
        <div id="lobby-status" class="status-msg"></div>
        <button class="menu-btn" style="background:#555; margin-top:20px; width: 200px;" onclick="backToMain()">BACK</button>
    </div>
</div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, collection, doc, setDoc, getDoc, onSnapshot, updateDoc, query, where, getDocs, serverTimestamp, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // --- FIREBASE CONFIG ---
    const firebaseConfig = {
      apiKey: "AIzaSyAKG5mW9aMqOry-GahwD5N--e7XFqWCZy0",
      authDomain: "slap-jam-game.firebaseapp.com",
      projectId: "slap-jam-game",
      storageBucket: "slap-jam-game.firebasestorage.app",
      messagingSenderId: "126537191246",
      appId: "1:126537191246:web:e47bffb5ea0d639beb981f",
      measurementId: "G-WMWMZZ5PVW"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    // --- AUDIO SYSTEM (SYNTH) ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let audioEnabled = false;
    let musicInterval = null;

    window.toggleAudio = () => {
        audioEnabled = !audioEnabled;
        const btn = document.getElementById('audio-toggle');
        btn.innerText = audioEnabled ? "ðŸ”Š" : "ðŸ”‡";
        btn.classList.toggle("on", audioEnabled);
        if(audioEnabled) {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            startMusic();
        } else {
            stopMusic();
        }
    };

    // Simple Synth Tone
    function playTone(freq, type, duration, vol=0.1) {
        if(!audioEnabled) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.type = type;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(vol, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    }

    // Music Sequencer
    function startMusic() {
        if(musicInterval) return;
        let step = 0;
        // Banger bassline sequence (E minor pentatonic-ish)
        const bass = [82, 0, 82, 82, 98, 0, 82, 0, 73, 0, 73, 73, 65, 0, 65, 0]; 
        const lead = [0, 0, 0, 0, 329, 0, 0, 0, 0, 0, 0, 0, 293, 0, 329, 0];
        
        musicInterval = setInterval(() => {
            if(!audioEnabled) return;
            // Bass
            if(bass[step % 16] > 0) playTone(bass[step%16], 'sawtooth', 0.2, 0.15);
            // Lead
            if(lead[step % 16] > 0) playTone(lead[step%16], 'square', 0.1, 0.05);
            // Kick Drum (Noise burst simulated by low freq sine drop)
            if(step % 4 === 0) playTone(150, 'sine', 0.1, 0.4); 
            
            step++;
        }, 150); // 100 BPM approx
    }

    function stopMusic() {
        if(musicInterval) clearInterval(musicInterval);
        musicInterval = null;
    }

    function playWinSound() {
        if(!audioEnabled) return;
        stopMusic();
        // Victory Arpeggio
        setTimeout(()=>playTone(523.25, 'square', 0.2, 0.2), 0);
        setTimeout(()=>playTone(659.25, 'square', 0.2, 0.2), 200);
        setTimeout(()=>playTone(783.99, 'square', 0.4, 0.2), 400);
        setTimeout(()=>playTone(1046.50, 'square', 0.8, 0.2), 600);
    }

    function playLoseSound() {
        if(!audioEnabled) return;
        stopMusic();
        // Sad slide
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.frequency.setValueAtTime(300, audioCtx.currentTime);
        osc.frequency.linearRampToValueAtTime(50, audioCtx.currentTime + 1.0);
        gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 1.0);
        osc.start(); osc.stop(audioCtx.currentTime+1);
    }

    // --- GAME STATE ---
    let user = null;
    let roomId = null;
    let isMultiplayer = false;
    let isHost = false; 
    let gameUnsubscribe = null;

    const STATE = { MENU: 0, P1_AIM: 1, P1_SLAP: 2, P2_AIM: 3, P2_SLAP: 4, OVER: 5, WAITING: 6 };
    let currentState = STATE.MENU;
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    function resizeGame() {
        const container = document.getElementById('game-container');
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        ctx.scale(canvas.width / 800, canvas.height / 600);
    }
    window.addEventListener('resize', resizeGame);

    const CHARS = [
        { name: "THE BOULDER", skin: "#d2a679", hair: "#3e2723", outfit: "#212121", pwr: 1.4, hp: 1.3, traits: { bald: true, beard: true, muscle: 1.0, fat: 0.1, height: 1.0 } },
        { name: "BEANPOLE BEN", skin: "#f5d0b0", hair: "#e65100", outfit: "#1b5e20", pwr: 0.9, hp: 0.8, traits: { bald: false, beard: false, muscle: 0.2, fat: 0.0, height: 1.3 } },
        { name: "BIG BARREL", skin: "#8d6e63", hair: "#000000", outfit: "#b71c1c", pwr: 1.2, hp: 1.5, traits: { bald: false, beard: true, muscle: 0.4, fat: 1.5, height: 0.9 } },
        { name: "TINY TIM", skin: "#ffccbc", hair: "#fdd835", outfit: "#0d47a1", pwr: 1.0, hp: 0.9, traits: { bald: false, beard: false, muscle: 0.6, fat: 0.1, height: 0.85 } }
    ];

    let myCharIdx = 0;
    let oppCharIdx = 1;
    let p1, p2; 
    
    let particles = [];
    let cameraShake = 0;
    let slowMo = 1.0;
    let meterVal = 0;
    let meterDir = 1;
    let meterSpeed = 2.0;
    let meterActive = false;
    let isMyTurn = false;
    let meterBounces = 0; // For power decay

    signInAnonymously(auth).then((u) => { user = u.user; }).catch(e => console.error(e));

    window.addEventListener('beforeunload', () => {
        if(roomId && isMultiplayer) {
            const roomRef = doc(db, 'games', roomId);
            if(isHost) deleteDoc(roomRef); else updateDoc(roomRef, { status: 'abandoned' });
        }
    });

    // --- MENU LOGIC ---
    window.backToMain = () => {
        playTone(300, 'sine', 0.1);
        if(gameUnsubscribe) gameUnsubscribe();
        document.getElementById('menu-multi').style.display = 'none';
        document.getElementById('menu-main').style.display = 'flex';
        roomId = null;
    };

    window.showMultiplayerMenu = () => {
        playTone(400, 'sine', 0.1);
        document.getElementById('menu-main').style.display = 'none';
        document.getElementById('menu-multi').style.display = 'flex';
        document.getElementById('selected-char-display').innerText = CHARS[myCharIdx].name;
    };

    window.startSinglePlayer = () => {
        playTone(500, 'square', 0.2);
        document.getElementById('menu-main').style.display = 'none';
        isMultiplayer = false;
        startGameLocal();
    };

    // --- CHAT LOGIC ---
    window.sendChatMessage = async () => {
        const input = document.getElementById('chat-input');
        const msg = input.value.toUpperCase();
        if(!msg) return;
        input.value = "";
        
        // Show local immediately
        if(isHost) p1.chat = { text: msg, time: 180 };
        else p1.chat = { text: msg, time: 180 }; // In multiplayer, p1 is always ME locally for chat logic? No, p1 is host.
        
        // Actually, logic is: p1 is ME in singleplayer. In multiplayer: p1 is HOST, p2 is JOINER.
        // We need to know who we are.
        const myPlayer = isHost ? p1 : p2;
        myPlayer.chat = { text: msg, time: 180 };

        if(isMultiplayer && roomId) {
            const roomRef = doc(db, 'games', roomId);
            // Update Firestore with chat
            const field = isHost ? 'p1Msg' : 'p2Msg';
            await updateDoc(roomRef, {
                [field]: { text: msg, id: Date.now() }
            });
        }
    };

    // --- MULTIPLAYER ROOMS ---
    window.createPrivateRoom = async () => {
        if(!user) return;
        const code = generateRoomCode();
        roomId = code;
        isHost = true;
        document.getElementById('lobby-status').innerText = `Room Created: ${code}\nWaiting...`;
        const roomRef = doc(db, 'games', code);
        await setDoc(roomRef, { p1: user.uid, p1Char: myCharIdx, status: 'waiting', createdAt: serverTimestamp() });
        waitForOpponent(code);
    };

    window.joinPrivateRoom = async () => {
        if(!user) return;
        const code = document.getElementById('room-code-input').value.toUpperCase();
        if(code.length !== 4) return;
        const roomRef = doc(db, 'games', code);
        const snap = await getDoc(roomRef);
        if(snap.exists() && snap.data().status === 'waiting' && snap.data().p1 !== user.uid) {
            roomId = code;
            isHost = false;
            document.getElementById('lobby-status').innerText = "Joining...";
            await updateDoc(roomRef, { p2: user.uid, p2Char: myCharIdx, status: 'ready' });
            listenToGame(code);
        } else {
            document.getElementById('lobby-status').innerText = "Invalid room.";
        }
    };

    window.findQuickMatch = async () => {
        if(!user) return;
        document.getElementById('lobby-status').innerText = "Searching...";
        const roomsRef = collection(db, 'games');
        const q = query(roomsRef, where('status', '==', 'waiting'));
        try {
            const querySnapshot = await getDocs(q);
            let found = null;
            querySnapshot.forEach(d => { if(d.data().p1 !== user.uid) found = d; });
            if(found) {
                roomId = found.id;
                isHost = false;
                const roomRef = doc(db, 'games', roomId);
                await updateDoc(roomRef, { p2: user.uid, p2Char: myCharIdx, status: 'ready' });
                listenToGame(roomId);
            } else {
                await createPrivateRoom();
            }
        } catch (e) {
            document.getElementById('lobby-status').innerText = "Connection error.";
        }
    };

    function generateRoomCode() {
        const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        let res = ""; for(let i=0; i<4; i++) res += chars.charAt(Math.floor(Math.random()*chars.length)); return res;
    }

    function waitForOpponent(code) {
        const roomRef = doc(db, 'games', code);
        const unsub = onSnapshot(roomRef, (snap) => {
            const d = snap.data();
            if(d && d.status === 'ready') {
                unsub();
                oppCharIdx = d.p2Char;
                startGameMultiplayer(true, d.p1Char, d.p2Char);
                setupGameplayListener(code);
            }
        });
        gameUnsubscribe = unsub;
    }

    function listenToGame(code) {
        const roomRef = doc(db, 'games', code);
        getDoc(roomRef).then(snap => {
            const d = snap.data();
            oppCharIdx = d.p1Char;
            startGameMultiplayer(false, d.p1Char, d.p2Char);
            setupGameplayListener(code);
        });
    }

    function setupGameplayListener(code) {
        const roomRef = doc(db, 'games', code);
        gameUnsubscribe = onSnapshot(roomRef, (snap) => {
            if(!snap.exists()) { announce("LEFT", "#f00"); setTimeout(backToMain, 3000); return; }
            const d = snap.data();
            if(d.status === 'abandoned') { announce("LEFT", "#f00"); setTimeout(backToMain, 3000); }
            if(d.lastAction) handleRemoteUpdate(d);
            
            // Sync Chat
            if(d.p1Msg && (!p1.lastMsgId || p1.lastMsgId !== d.p1Msg.id)) {
                p1.chat = { text: d.p1Msg.text, time: 180 };
                p1.lastMsgId = d.p1Msg.id;
            }
            if(d.p2Msg && (!p2.lastMsgId || p2.lastMsgId !== d.p2Msg.id)) {
                p2.chat = { text: d.p2Msg.text, time: 180 };
                p2.lastMsgId = d.p2Msg.id;
            }
        });
    }

    // --- GAME ENGINE ---

    function startGameLocal() {
        let cpuIdx = (myCharIdx + 1) % CHARS.length;
        p1 = new Fighter(250, 400, CHARS[myCharIdx], false);
        p2 = new Fighter(550, 400, CHARS[cpuIdx], true);
        p2.facing = -1;
        setupGameUI(p1, p2);
        currentState = STATE.P1_AIM;
        startTurnLocal();
        resizeGame();
        document.getElementById('chat-input-area').style.display = 'none'; // No chat in singleplayer
        requestAnimationFrame(gameLoop);
    }

    function startGameMultiplayer(host, c1Idx, c2Idx) {
        document.getElementById('menu-multi').style.display = 'none';
        isMultiplayer = true;
        isHost = host;
        
        p1 = new Fighter(250, 400, CHARS[c1Idx], false);
        p2 = new Fighter(550, 400, CHARS[c2Idx], false); 
        p2.facing = -1;

        setupGameUI(p1, p2);
        resizeGame();
        
        document.getElementById('chat-input-area').style.display = 'flex';

        if(isHost) {
            isMyTurn = true;
            startTurnMultiplayerAim();
        } else {
            isMyTurn = false;
            currentState = STATE.P1_AIM;
            document.getElementById('turn-indicator').innerText = "OPPONENT TURN";
            document.getElementById('turn-indicator').style.opacity = 1;
        }
        requestAnimationFrame(gameLoop);
    }

    function setupGameUI(f1, f2) {
        document.getElementById('p1-name').innerText = f1.data.name;
        document.getElementById('p2-name').innerText = f2.data.name;
        const c1 = document.getElementById('p1-profile'); renderProfile(c1.getContext('2d'), f1.data, c1.width, c1.height);
        const c2 = document.getElementById('p2-profile'); renderProfile(c2.getContext('2d'), f2.data, c2.width, c2.height);
        if(roomId) document.getElementById('room-display').innerText = "ROOM: " + roomId;
    }

    let lastTime = 0;
    function gameLoop(timestamp) {
        let dt = (timestamp - lastTime) / 1000;
        lastTime = timestamp;
        let simDt = dt * slowMo;
        if(slowMo < 1.0) slowMo += dt * 0.8; if(slowMo>1) slowMo=1;
        update(simDt);
        draw();
        requestAnimationFrame(gameLoop);
    }

    function update(dt) {
        if(cameraShake > 0) cameraShake *= 0.9;
        
        // Meter Logic
        if(meterActive && (!isMultiplayer || isMyTurn)) {
            meterVal += meterSpeed * meterDir * dt * 60;
            if(meterVal > 100) { 
                meterVal = 100; meterDir = -1; 
                meterBounces++; 
            }
            if(meterVal < 0) { 
                meterVal = 0; meterDir = 1; 
                meterBounces++; 
            }
            
            // Calculate Power Decay
            // Lose 5% power every bounce, cap at 50% loss
            let decay = Math.max(0.5, 1.0 - (meterBounces * 0.05));
            document.getElementById('power-decay-label').innerText = `POTENTIAL POWER: ${Math.round(decay*100)}%`;
            document.getElementById('power-decay-label').style.color = decay > 0.8 ? "#0f0" : (decay > 0.6 ? "#ff0" : "#f00");

            document.getElementById('needle').style.left = meterVal + "%";
        }

        if(!isMultiplayer && currentState === STATE.P2_AIM) {
            if(!p2.aiTimer) p2.aiTimer = 1.0 + Math.random();
            p2.aiTimer -= dt;
            if(p2.aiTimer <= 0) {
                p2.aiTimer = 9999; 
                meterBounces = 2; // CPU waits a bit
                let roll = Math.random();
                if(roll > 0.7) meterVal = 50; else if (roll > 0.3) meterVal = 35; else meterVal = 10; 
                resolveSlapLocal(p2, p1);
            }
        }

        if(p1) p1.update(dt);
        if(p2) p2.update(dt);
        for(let i=particles.length-1; i>=0; i--) {
            let p = particles[i];
            p.x += p.vx; p.y += p.vy; p.vy += 0.5; p.life -= dt * 2;
            if(p.life <= 0) particles.splice(i, 1);
        }
    }

    window.addEventListener('keydown', e => { if(e.code === 'Space') handleInput(); });
    const btn = document.getElementById('action-btn');
    btn.addEventListener('mousedown', (e)=>{e.preventDefault(); handleInput();});
    btn.addEventListener('touchstart', (e)=>{e.preventDefault(); handleInput();});

    function handleInput() {
        if(currentState === STATE.OVER) { location.reload(); return; }
        if(isMultiplayer) {
            if(isMyTurn && meterActive) commitSlapMultiplayer();
        } else {
            if(currentState === STATE.P1_AIM && meterActive) resolveSlapLocal(p1, p2);
        }
    }

    function startTurnLocal() {
        currentState = STATE.P1_AIM;
        showMeter("YOUR TURN", true);
        meterActive = true; meterVal = 0; meterBounces = 0;
    }

    function resolveSlapLocal(atk, def) {
        hideMeter();
        meterActive = false;
        if(atk === p2) currentState = STATE.P2_SLAP; 
        else currentState = STATE.P1_SLAP;

        // Apply Decay
        let decay = Math.max(0.5, 1.0 - (meterBounces * 0.05));
        const res = calculateResult(meterVal);
        res.mult *= decay; // Reduce power based on time taken

        performSlapSequence(atk, def, res.mult, res.qual, () => {
            if(def.hp > 0) {
                if(atk === p1) { currentState = STATE.P2_AIM; showMeter("CPU TURN", false); p2.aiTimer = null; } 
                else startTurnLocal();
            }
        });
    }

    function startTurnMultiplayerAim() {
        meterActive = true; meterVal = 0; meterBounces = 0;
        showMeter("YOUR TURN", true);
    }

    async function commitSlapMultiplayer() {
        meterActive = false;
        hideMeter();
        isMyTurn = false;
        
        let decay = Math.max(0.5, 1.0 - (meterBounces * 0.05));
        const res = calculateResult(meterVal);
        res.mult *= decay;

        const roomRef = doc(db, 'games', roomId);
        await updateDoc(roomRef, {
            lastAction: {
                attacker: isHost ? 'p1' : 'p2',
                val: meterVal,
                mult: res.mult,
                qual: res.qual,
                timestamp: Date.now()
            }
        });
    }

    function handleRemoteUpdate(data) {
        if(!data.lastAction) return;
        const act = data.lastAction;
        if(p1.lastActionTime === act.timestamp) return;
        p1.lastActionTime = act.timestamp;

        const attacker = act.attacker === 'p1' ? p1 : p2;
        const defender = act.attacker === 'p1' ? p2 : p1;

        performSlapSequence(attacker, defender, act.mult, act.qual, () => {
            if(defender.hp > 0) {
                if((isHost && act.attacker === 'p2') || (!isHost && act.attacker === 'p1')) {
                    isMyTurn = true;
                    startTurnMultiplayerAim();
                } else {
                    isMyTurn = false;
                    showMeter("OPPONENT TURN", false);
                }
            }
        });
    }

    function calculateResult(val) {
        let dist = Math.abs(50 - val);
        if(dist < 4) return { qual: 2, mult: 2.0 };
        if(dist < 20) return { qual: 1, mult: 1.2 };
        return { qual: 0, mult: 0.5 };
    }

    function performSlapSequence(atk, def, mult, qual, onComplete) {
        atk.state = 'WINDUP';
        atk.animTimer = 0;
        setTimeout(() => {
            atk.state = 'SLAP';
            atk.animTimer = 0;
            setTimeout(() => {
                // Sound
                playTone(100, 'noise', 0.1); 
                if(qual === 2) playTone(600, 'sawtooth', 0.2);
                applyHit(atk, def, mult, qual);
            }, 100); 
            setTimeout(() => {
                atk.state = 'IDLE';
                if(def.hp > 0) { def.state = 'IDLE'; onComplete(); }
            }, 1500);
        }, 600);
    }

    function applyHit(atk, def, mult, qual) {
        cameraShake = 20 * mult;
        def.state = 'HURT';
        def.animTimer = 0;
        let dmg = 15 * atk.data.pwr * mult;
        def.hp -= dmg;
        let bar = def === p1 ? document.getElementById('p1-hp') : document.getElementById('p2-hp');
        bar.style.width = Math.max(0, (def.hp / def.maxHp) * 100) + "%";

        if(qual === 2) {
            slowMo = 0.1; announce("PERFECT!", "#00ff00");
            spawnParticles(def.x, def.y - 60, 30, "white"); spawnParticles(def.x, def.y - 60, 10, "red");
            def.wobble = 20;
        } else if (qual === 1) {
            announce("CRACK!", "#ffff00");
            spawnParticles(def.x, def.y - 60, 15, "white");
            def.wobble = 10;
        } else {
            announce("WHIFF", "#888");
            def.wobble = 2;
        }
        if(def.hp <= 0) setTimeout(() => endGame(atk), 1000);
    }

    function endGame(winner) {
        currentState = STATE.OVER;
        let isWin = (isMultiplayer && ((isHost && winner===p1) || (!isHost && winner===p2))) || (!isMultiplayer && winner===p1);
        announce(isWin ? "YOU WIN!" : "KNOCKED OUT!", isWin ? "#0f0" : "#f00");
        document.getElementById('action-btn').innerText = "RELOAD";
        document.getElementById('action-btn').style.display = 'block';
        if(isWin) playWinSound(); else playLoseSound();
    }

    // --- UI HELPERS ---
    function showMeter(text, btnVisible) {
        document.getElementById('turn-indicator').innerText = text;
        document.getElementById('turn-indicator').style.opacity = 1;
        document.getElementById('meter-wrapper').style.display = 'flex';
        document.getElementById('action-btn').style.display = btnVisible ? 'block' : 'none';
        document.getElementById('action-btn').innerText = "SLAP!";
    }
    function hideMeter() {
        document.getElementById('meter-wrapper').style.display = 'none';
        document.getElementById('action-btn').style.display = 'none';
        document.getElementById('turn-indicator').style.opacity = 0;
    }
    function announce(t,c) {
        const el = document.getElementById('announcer');
        el.innerText = t; el.style.color = c; el.style.opacity = 0;
        el.animate([{opacity:0, transform:"translate(-50%,-50%) scale(0.5)"}, {opacity:1, transform:"translate(-50%,-50%) scale(1.2)"}, {opacity:0}], {duration: 1000});
    }
    function spawnParticles(x, y, n, c) {
        for(let i=0;i<n;i++) particles.push({x:x, y:y, vx:(Math.random()*10)+5, vy:(Math.random()-0.5)*20, life:1.0, size:Math.random()*5, color:c});
    }

    // --- ART DRAWING ---
    const charList = document.getElementById('char-list');

    function renderProfile(c, char, w, h) {
        c.fillStyle = "#333"; c.fillRect(0,0,w,h);
        let grad = c.createRadialGradient(w/2, h/2, 10, w/2, h/2, 50);
        grad.addColorStop(0, "#555"); grad.addColorStop(1, "#222");
        c.fillStyle = grad; c.fillRect(0,0,w,h);
        c.save(); c.translate(w/2, h/2 + 10); c.scale(1.2, 1.2);
        drawHead(c, char, 60, 60); c.restore();
    }
    
    function drawHead(ctx, char, w, h) {
        const t = char.traits;
        ctx.fillStyle = char.skin; ctx.beginPath();
        if(t.fat > 1.0) ctx.ellipse(0, 0, w*0.6, h*0.55, 0, 0, Math.PI*2);
        else if (t.height > 1.2) ctx.ellipse(0, 0, w*0.4, h*0.6, 0, 0, Math.PI*2);
        else if (t.muscle > 0.8) ctx.roundRect(-w*0.45, -h*0.5, w*0.9, h*0.9, 10);
        else ctx.ellipse(0, 0, w*0.45, h*0.5, 0, 0, Math.PI*2);
        ctx.fill();

        ctx.fillStyle = char.hair;
        if(!t.bald) {
            ctx.beginPath();
            if(t.fat > 1.0) ctx.arc(0, -h*0.5, w*0.6, Math.PI, 0); 
            else if (t.height > 1.2) { ctx.moveTo(-w*0.5, -h*0.3); ctx.lineTo(0, -h*0.8); ctx.lineTo(w*0.5, -h*0.3); }
            else ctx.arc(0, -h*0.4, w*0.48, Math.PI, 0);
            ctx.fill();
        }
        if(t.beard) { ctx.fillStyle = char.hair; ctx.beginPath(); ctx.arc(0, h*0.4, w*0.2, 0, Math.PI, false); ctx.fill(); }
        ctx.fillStyle = "white"; ctx.beginPath(); ctx.arc(-w*0.15, -h*0.1, 4, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(w*0.15, -h*0.1, 4, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "black"; ctx.beginPath(); ctx.arc(-w*0.15, -h*0.1, 1.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(w*0.15, -h*0.1, 1.5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "#5d4037"; ctx.fillRect(-5, h*0.25, 10, 2);
    }

    CHARS.forEach((char, i) => {
        let div = document.createElement('div');
        div.className = 'char-icon';
        let cvs = document.createElement('canvas');
        cvs.width = 100; cvs.height = 100;
        renderProfile(cvs.getContext('2d'), char, 100, 100);
        div.appendChild(cvs);
        div.onclick = () => selectChar(i, div);
        charList.appendChild(div);
    });
    selectChar(0, charList.children[0]);

    function selectChar(idx, el) {
        myCharIdx = idx;
        Array.from(charList.children).forEach(c => c.classList.remove('selected'));
        el.classList.add('selected');
        document.getElementById('char-stats').innerText = `${CHARS[idx].name} // PWR:${CHARS[idx].pwr} HP:${CHARS[idx].hp}`;
    }

    function drawLimb(ctx, x, y, w, h, color, angle) {
        ctx.save(); ctx.translate(x, y); ctx.rotate(angle);
        let grad = ctx.createLinearGradient(-w/2, 0, w/2, 0);
        grad.addColorStop(0, color); grad.addColorStop(0.5, color); grad.addColorStop(1, color); 
        ctx.fillStyle = grad; ctx.beginPath(); ctx.roundRect(-w/2, 0, w, h, w/2); ctx.fill(); ctx.restore();
    }

    class Fighter {
        constructor(x, y, data, isCpu) {
            this.x = x; this.y = y;
            this.data = data;
            this.maxHp = 100 * data.hp;
            this.hp = this.maxHp;
            this.facing = 1;
            this.state = 'IDLE'; 
            this.animTimer = 0;
            this.wobble = 0;
            this.lastActionTime = 0;
            this.chat = null;
        }
        update(dt) { 
            this.animTimer += dt; 
            this.wobble *= 0.9; 
            if(this.chat) {
                this.chat.time -= dt;
                if(this.chat.time <= 0) this.chat = null;
            }
        }
    }

    function draw() {
        ctx.fillStyle = "#111"; ctx.fillRect(0,0, canvas.width, canvas.height);
        let grad = ctx.createRadialGradient(400, 300, 50, 400, 300, 500);
        grad.addColorStop(0, "#222"); grad.addColorStop(1, "#050505");
        ctx.fillStyle = grad; ctx.fillRect(0,0, canvas.width, canvas.height);

        ctx.save();
        ctx.translate((Math.random()-0.5)*cameraShake, (Math.random()-0.5)*cameraShake);
        
        ctx.fillStyle = "#222"; ctx.fillRect(300, 400, 200, 200); 
        ctx.fillStyle = "#444"; ctx.beginPath(); ctx.ellipse(400, 400, 120, 40, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "#111"; ctx.beginPath(); ctx.ellipse(400, 400, 100, 30, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "#888"; 
        ctx.fillRect(320, 380, 10, 30); ctx.fillRect(320, 380, 30, 5);
        ctx.fillRect(470, 380, 10, 30); ctx.fillRect(450, 380, 30, 5);

        if(p1) drawFighter(p1);
        if(p2) drawFighter(p2);

        particles.forEach(p => {
            ctx.fillStyle = p.color; ctx.globalAlpha = p.life;
            ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
        });
        ctx.globalAlpha = 1;
        ctx.restore();
    }

    function drawFighter(f) {
        ctx.save(); ctx.translate(f.x, f.y); ctx.scale(f.facing, 1);
        const t = f.data.traits;
        let bodyRot = 0.1; let armRot = 0; let headOffX = 0; let headOffY = 0;

        if (f.state === 'WINDUP') { bodyRot = -0.15; armRot = -2.2; }
        else if (f.state === 'SLAP') { bodyRot = 0.3; armRot = 1.8; }
        else if (f.state === 'HURT') { bodyRot = -0.4; headOffX = -10 - (Math.random()*f.wobble); }

        ctx.save(); ctx.rotate(bodyRot);
        drawLimb(ctx, 45, -20, 15*t.muscle, 50*t.height, f.data.skin, 0.4); 
        ctx.restore();

        ctx.save(); ctx.rotate(bodyRot);
        ctx.fillStyle = f.data.outfit; ctx.beginPath();
        if(t.fat > 1.0) ctx.ellipse(0, 20, 50, 60, 0, 0, Math.PI*2);
        else if (t.muscle > 0.8) { ctx.moveTo(-35, -50); ctx.lineTo(35, -50); ctx.lineTo(20, 60); ctx.lineTo(-20, 60); }
        else ctx.ellipse(0, 10, 25, 60, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.translate(headOffX, -50 + headOffY);
        drawHead(ctx, f.data, 60, 70);
        ctx.restore();

        if(f.state !== 'HURT') {
            ctx.save(); ctx.translate(10, -40); ctx.rotate(bodyRot + armRot);
            drawLimb(ctx, 0, 25, 20*t.muscle, 50*t.height, f.data.skin, 0);
            ctx.translate(0, 50*t.height);
            if(f.state === 'SLAP') drawLimb(ctx, 0, 25, 18*t.muscle, 50*t.height, f.data.skin, 0);
            else drawLimb(ctx, 20, 0, 18*t.muscle, 50*t.height, f.data.skin, -1.5);
            ctx.fillStyle = f.data.skin; ctx.beginPath();
            if(f.state === 'SLAP') ctx.arc(0, 60*t.height, 25, 0, Math.PI*2);
            else ctx.arc(45, 0, 20, 0, Math.PI*2);
            ctx.fill();
            ctx.restore();
        }
        ctx.restore();

        // CHAT BUBBLE
        if(f.chat) {
            ctx.save();
            ctx.translate(0, -130);
            ctx.scale(f.facing, 1); // unflip text
            ctx.fillStyle = "white";
            ctx.beginPath(); ctx.roundRect(-60, -20, 120, 30, 5); ctx.fill();
            ctx.fillStyle = "black";
            ctx.font = "12px 'Press Start 2P'";
            ctx.textAlign = "center";
            ctx.fillText(f.chat.text, 0, 5);
            ctx.restore();
        }
    }
</script>
</body>
</html>
